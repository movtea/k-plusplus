# k-plusplus

# Перед сборкой
## Зависимости
Для сборки данного репозитория необходимы несколько зависимостей(установите их сами, в зависимости от вашего дистрибутива):
- gcc/g++ - компилторы для сборки на Linux и MacOS
- CMake >=3.21 - для создания Makefile и последующей сборки под вашу платформу
- Make - сборка итогового приложения
- MingGW - компилтор для windows
**Примечания**:
- gcc/g++ является опциональной зависимостью для windows(для остальных платформ обязательно)
- MinGW - опиональная зависимость для Linux и MacOS(необходимо только для кросс-компиляции)
- Для Linux все зависмости устанавливаются в зависмости от вашего дистрибутива
- Для MacOS все устанавливается из brew(не проверялось, работа не гарантируется)
- Make для windows поставляется вместе с MinGW. Рекомендуется использовать готовые бинарные пакеты: https://github.com/niXman/mingw-builds-binaries/releases
- Для windows рекомендуется использовать сборки MinGW с обозначением по типу "что-тотам-posix-seh-msvcrt-что-тотам.zip"
- Все директории, где хранятся исполняемые файлы mingw должны быть добавлены в переменную Path

# Сборка проекта
## Сборка под Linux/MacOS
1) Склонировать репозиторий
2) перейти в директорию build в репозитории
3) cmake ..
4) make
5) Запустить исполняемый файл k-pp

## Сборка под Windows
1) Склонировать репозиторий
2) Открыть cmake-gui
3) Выбрать папку с кодом по примеру: C:\your\path\to\repo
4) Выбрать директорию куда будут сохраняться скомпилированные библиотеки и исполняемые файлы по примеру: C:\your\path\to\repo\build
5) Нажать configure, далее MinGW Makefiles. Также выбрать галочку "specify native compilers"
6) Для С укажите путь до файла: x86_64-w64-mingw32-gcc.exe
7) Для C++ укажите путь до файла: x86_64-w64-mingw32-g++.exe
8) Для Fortran: x86_64-w64-mingw32-gfortran.exe
9) В случае успешной конфигурации в окне внизу появится надпись "Configuring done"
10) Нажмите кнопку generate(если все правильно, то увидите generating done)
11) Откройте терминал, перейдите в директорию из пункта 4
12) Выполните mingw32-make
13) Запустите исполняемый файл k-pp.exe

## Кросс-компиляция (Компиляция под Windows на Linux)
Выполните те же шаги, что и для обчный компиляции, но вместо команды "cmake .." Выполните: cmake .. -DCMAKE_TOOLCHAIN_FILE=./toolchains/windows.txt
Таким образом сможете получить k-pp.exe(возможно работает на MacOS)

# Немного правил

1. Описывать код с комментариями, как приведено ниже
2. В репозитории необходимо создавать модули в папке /src с названием модуля с основным кодом и его библиотекой, в папке /lib создавать папки подключаемых библиотек, необходимых для работы кода (Пример дерева выше, все директории с "+" в начале названия)
3. Потом

# Описание

Данное приложение анализирует содержимое заданного каталога (со всеми подкаталогами), считает хэш-суммы всех файлов и проверяет, упоминаются ли эти файлы в базе данных NSRL. На выходе будет создана база данных SQLite, состоящая из двух таблиц. В одной содержатся пути к файлам, которые упоминаются в NSRL, а в другой - файлы, которые не были найдены в базе NSRL.

## Структура проекта

```
k-plusplus/
|-- src/
|   |-- main.cpp
|   |-- nsrlRepository/
|   |   |-- nsrlRepository.cpp
|   |   |-- nsrlRepository.h
|   |-- +moduleNew/
|   |   |-- +moduleNew.cpp
|   |   |-- +moduleNew.h
|-- lib/
|   |-- sqlite3/
|   |   |-- sqlite3.c
|   |   |-- sqlite3.h
|   |-- +libraryNew/
|   |   |-- +libraryNew.c
|   |   |-- +libraryNew.h
|-- tests/
|   |-- +new_unit_tests.cpp
|-- build/
|-- doc/
|-- models/
|   |-- fileSchema.h
|-- Makefile
|-- README.md
```

- **src** : содержит файлы исходного кода, включая основную точку входа приложения. и различные модули.
- **lib** : для сторонних библиотек или внешних зависимостей. Пример sqlite3 и cryptopp.
- **tests** : Содержит модульные тесты.
- **build** : Каталог для артефактов сборки. Все объектные файлы.
- **doc** : хранилище для файлов документации. (Возможно понадобится для картинок)
- **Makefile** : файл конфигурации Make.
- **README.md** : документация Markdown с инструкциями по проекту.

### Какие модули у нас будут

1. Модуль для работы с базой данных NSRL.
2. Модуль для работы с базой в которой будет ответ.
3. Модуль для получения списка всех файлов в директории.
4. Модуль для получения хеш с помощью cryptopp.

Модель File:

- name
- path
- hash-sha1
- hash-sha256
- hash-md5
- hash-crc32

За подробностями models/fileSchema.h или к архитектору)

## Описание модулей

### Модуль для работы с базой данных NSRL.

Инструкция использования:

```c++

try
{
    // Создание объекта репозитория
    NSRLRepository nsrlRepo;

    // Создание объекта файла
    File testFile;
    testFile.name = "Test";
    testFile.hash_sha1 = "no";

    if (nsrlRepo.IsHashInDB(&testFile)){
        cout << "Если есть файл в бд"
    } else {
        cout << "Если нет файла в бд"
    }
}
catch (const NSRLRepository::OpenDBException &ex) // Если произошло исключение при открытии БД
{
    cout << "Ошибка открытия БД SQLite № " << ex.error << endl;
    return 1;
}
```

### Модуль для обхода заданной директории.

Инструкция использования:

```c++
vector<FilePtr> filename  = dir("/path/to/dir");

for(int i = 0; i < filename.size(); i++)
{
    cout << filename[i]->name<< endl;
    cout << filename[i]->path<< endl;
}

filename.clear();
```

### Модуль для получения хеш с помощью cryptopp.

Перед запуском нужно распаковать статическую библиотеку.

1. По пути <проект>/lib/cryptopp/libcryptopp.zip распаковать в в эту же директорию.
